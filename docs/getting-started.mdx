---
title: "Getting Started"
description: "This guide will help you install Oite and build your first program."
---

## Installation[​](#installation "Direct link to Installation")

### Step 1: Install Prerequisites[​](#step-1-install-prerequisites "Direct link to Step 1: Install Prerequisites")

**macOS:**

```
# Install Rust (if not already installed)curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh# Install LLVM 18 (required for AOT compilation)brew install llvm@18# Install zstd (required for linking)brew install zstd# Set LLVM environment variable (add to ~/.zshrc or ~/.bashrc)echo 'export LLVM_SYS_180_PREFIX=$(brew --prefix llvm@18)' >> ~/.zshrcsource ~/.zshrc
```

**Linux (Ubuntu/Debian):**

```
# Install Rustcurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh# Install LLVM 18wget https://apt.llvm.org/llvm.shchmod +x llvm.shsudo ./llvm.sh 18# Install zstdsudo apt install libzstd-dev# Set LLVM pathecho 'export LLVM_SYS_180_PREFIX=/usr/lib/llvm-18' >> ~/.bashrcsource ~/.bashrc
```

<Note>
  The Cranelift JIT backend works without LLVM. LLVM is only required for AOT (ahead-of-time) compilation to native binaries.
</Note>

### Step 2: Clone and Build Oite[​](#step-2-clone-and-build-oite "Direct link to Step 2: Clone and Build Oite")

```
# Clone the repositorygit clone https://github.com/warpy-ai/oite.gitcd oite# Build in release modecargo build --release# Verify installation./target/release/oite --help
```

### Step 3: Add to PATH (Optional)[​](#step-3-add-to-path-optional "Direct link to Step 3: Add to PATH (Optional)")

```
# Add Oite to your PATHecho 'export PATH="$PATH:/path/to/oite/target/release"' >> ~/.zshrcsource ~/.zshrc# Now you can run from anywhereoite --help
```

## Your First Oite Program[​](#your-first-oite-program "Direct link to Your First Oite Program")

### Hello World[​](#hello-world "Direct link to Hello World")

Create a file called `hello.ot`:

```
console.log("Hello, Oite!");
```

Run it:

```
./target/release/oite hello.ot
```

### A More Complete Example[​](#a-more-complete-example "Direct link to A More Complete Example")

Create `fibonacci.ot`:

```
function fib(n: number): number {  if (n < 2) return n;  return fib(n - 1) + fib(n - 2);}let result = fib(25);console.log("Fibonacci(25) =", result);
```

Run with different backends:

```
# VM (interpreted, good for debugging)./target/release/oite fibonacci.ot# JIT (fast compilation, good for development)./target/release/oite jit fibonacci.ot# AOT (native binary, best performance)./target/release/oite build fibonacci.ot --release -o fib./fib
```

## Execution Modes[​](#execution-modes "Direct link to Execution Modes")

Oite provides multiple ways to run your code:

| Mode            | Command                              | Use Case                        | Performance |
| --------------- | ------------------------------------ | ------------------------------- | ----------- |
| **VM**          | `oite app.ot`                        | Debugging, REPL                 | Slowest     |
| **JIT**         | `oite jit app.ot`                    | Development, testing            | Fast        |
| **AOT Release** | `oite build app.ot --release -o app` | Production (ThinLTO)            | Faster      |
| **AOT Dist**    | `oite build app.ot --dist -o app`    | Maximum optimization (Full LTO) | Fastest     |

### JIT Compilation (Development)[​](#jit-compilation-development "Direct link to JIT Compilation (Development)")

```
./target/release/oite jit app.ot
```

Uses Cranelift for fast compilation. Perfect for rapid iteration.

### AOT Compilation (Production)[​](#aot-compilation-production "Direct link to AOT Compilation (Production)")

```
# Release build with ThinLTO./target/release/oite build app.ot --release -o app# Distribution build with Full LTO (slower compile, faster runtime)./target/release/oite build app.ot --dist -o app# Run the native binary./app
```

Produces standalone executables with no runtime dependencies.

### VM Execution (Debugging)[​](#vm-execution-debugging "Direct link to VM Execution (Debugging)")

```
./target/release/oite app.ot
```

Interpreted execution for debugging and testing.

## CLI Reference[​](#cli-reference "Direct link to CLI Reference")

```
# Run with VMoite <file.ot># Run with JIToite jit <file.ot># Build native binaryoite build <file.ot> [--release|--dist] -o <output># Show SSA IR (debugging)oite ir <file.ot># Show AST (debugging)oite ast <file.ot># Type check onlyoite check <file.ot>
```

## Project Structure[​](#project-structure "Direct link to Project Structure")

A typical Oite project looks like:

```
my-project/├── main.ot             # Entry point├── lib/│   ├── utils.ot        # Utility functions│   └── types.ot        # Type definitions└── tests/    └── test_utils.ot   # Tests
```

### Importing Modules[​](#importing-modules "Direct link to Importing Modules")

```
// main.otimport { helper } from "./lib/utils";let result = helper(42);console.log(result);
```

```
// lib/utils.otexport function helper(x: number): number {  return x * 2;}
```

## What's Next?[​](#whats-next "Direct link to What's Next?")

Now that you have Oite running, explore:

* [Language Features](/compiler/language-features) — Variables, functions, classes, and more
* [Architecture](/compiler/architecture) — How Oite works under the hood
* [Standard Library](/compiler/standard-library) — Built-in functions and modules
* [Memory Model](/rolls/memory-model) — Ownership and borrow checking
* [Development Status](/development-status) — Current state and roadmap

[Edit this page](https://github.com/warpy-ai/script/tree/main/docs/docs/getting-started.md)
