---
title: "Lifetime Parameters"
description: "Lifetimes are Oite's way of tracking how long references are valid. They enable you to write functions that return borrowed references safely, without copying data."
---

## Why Lifetimes Matter[​](#why-lifetimes-matter "Direct link to Why Lifetimes Matter")

Oite uses **ownership-based memory management** (like Rust), not garbage collection. When you borrow data with `&`, the compiler needs to ensure you don't use that reference after the original data is freed.

```
// Problem: Which input does the return value borrow from?function pick(a: &string, b: &string): &string {    return a;  // Returns reference to 'a'}let result;{    let s1 = "hello";    let s2 = "world";    result = pick(&s1, &s2);}  // s1 and s2 are freed here!console.log(result);  // ERROR: dangling reference!
```

Lifetimes solve this by explicitly tracking which input the output borrows from.

## Basic Syntax[​](#basic-syntax "Direct link to Basic Syntax")

### Lifetime Parameters[​](#lifetime-parameters-1 "Direct link to Lifetime Parameters")

Lifetime parameters are declared with a leading apostrophe:

```
// 'a is a lifetime parameterfunction find<'a>(haystack: &'a number[], needle: number): &'a number | null {    for (let i = 0; i < haystack.length; i++) {        if (haystack[i] === needle) {            return &haystack[i];        }    }    return null;}
```

The `'a` connects the input and output: the returned reference lives as long as `haystack`.

### Reference Types with Lifetimes[​](#reference-types-with-lifetimes "Direct link to Reference Types with Lifetimes")

| Syntax      | Meaning                              |
| ----------- | ------------------------------------ |
| `&T`        | Immutable borrow (lifetime inferred) |
| `&mut T`    | Mutable borrow (lifetime inferred)   |
| `&'a T`     | Immutable borrow with lifetime `'a`  |
| `&'a mut T` | Mutable borrow with lifetime `'a`    |

### The `'static` Lifetime[​](#the-static-lifetime "Direct link to the-static-lifetime")

The special `'static` lifetime means "lives for the entire program":

```
// String literals are 'staticlet s: &'static string = "hello world";// Constants are 'staticconst CONFIG: &'static Config = { debug: true };
```

## Lifetime Elision (When You Don't Need Lifetimes)[​](#lifetime-elision-when-you-dont-need-lifetimes "Direct link to Lifetime Elision (When You Don't Need Lifetimes)")

Most of the time, you don't need to write lifetimes explicitly. The compiler infers them using these rules:

### Rule 1: Single Input Reference[​](#rule-1-single-input-reference "Direct link to Rule 1: Single Input Reference")

If there's exactly one input reference, the output gets the same lifetime:

```
// You write:function first(arr: &number[]): &number {    return arr[0];}// Compiler sees:function first<'a>(arr: &'a number[]): &'a number {    return arr[0];}
```

### Rule 2: Method Receiver[​](#rule-2-method-receiver "Direct link to Rule 2: Method Receiver")

For methods, the output borrows from `self`:

```
class Vec<T> {    // You write:    get(index: number): &T | null {        return this.data[index];    }    // Compiler sees:    get<'self>(index: number): &'self T | null {        return this.data[index];    }}
```

### Rule 3: Multiple Inputs (Explicit Required)[​](#rule-3-multiple-inputs-explicit-required "Direct link to Rule 3: Multiple Inputs (Explicit Required)")

When there are multiple input references and no `self`, you must be explicit:

```
// ERROR: Ambiguous - which input does output borrow from?function longest(a: &string, b: &string): &string {    return a.length >= b.length ? a : b;}// CORRECT: Explicit lifetime shows both inputs must live as long as outputfunction longest<'a>(a: &'a string, b: &'a string): &'a string {    return a.length >= b.length ? a : b;}
```

## Common Patterns[​](#common-patterns "Direct link to Common Patterns")

### Finding Elements[​](#finding-elements "Direct link to Finding Elements")

```
// Return reference to element in collectionfunction find<'a, T>(arr: &'a T[], predicate: (x: &T) => boolean): &'a T | null {    for (let i = 0; i < arr.length; i++) {        if (predicate(&arr[i])) {            return &arr[i];        }    }    return null;}// Usagelet numbers = [1, 2, 3, 4, 5];let found = find(&numbers, x => x > 3);console.log(found);  // 4
```

### String Views (Zero-Copy Slicing)[​](#string-views-zero-copy-slicing "Direct link to String Views (Zero-Copy Slicing)")

```
struct StringView<'a> {    source: &'a string;    start: number;    len: number;}function slice<'a>(s: &'a string, start: number, len: number): StringView<'a> {    return { source: s, start: start, len: len };}// No copying - just a view into the original stringlet text = "hello world";let view = slice(&text, 0, 5);  // view borrows from text
```

### Iterators[​](#iterators "Direct link to Iterators")

```
struct ArrayIter<'a, T> {    data: &'a T[];    index: number;}function iter<'a, T>(arr: &'a T[]): ArrayIter<'a, T> {    return { data: arr, index: 0 };}function next<'a, T>(it: &mut ArrayIter<'a, T>): &'a T | null {    if (it.index >= it.data.length) {        return null;    }    let result = &it.data[it.index];    it.index = it.index + 1;    return result;}// Usagelet items = [1, 2, 3];let it = iter(&items);while (let item = next(&mut it)) {    console.log(item);}
```

## Lifetime Variance[​](#lifetime-variance "Direct link to Lifetime Variance")

References have different "variance" rules:

| Type        | Variance  | Meaning                                    |
| ----------- | --------- | ------------------------------------------ |
| `&'a T`     | Covariant | Can shorten lifetime (longer → shorter OK) |
| `&'a mut T` | Invariant | Must be exact match                        |

```
// Covariant: longer lifetime can be used where shorter expectedlet long_ref: &'long T = ...;let short_ref: &'short T = long_ref;  // OK if 'long outlives 'short// Invariant: mutable refs must match exactlylet mut_ref: &'a mut T = ...;let other: &'b mut T = mut_ref;  // ERROR unless 'a == 'b
```

## Error Messages[​](#error-messages "Direct link to Error Messages")

### E0501: Cannot Return Reference to Local Variable[​](#e0501-cannot-return-reference-to-local-variable "Direct link to E0501: Cannot Return Reference to Local Variable")

```
error[E0501]: cannot return reference to local variable  --> src/example.ot:5:12   | 4 |     let local = [1, 2, 3];   |         ----- local variable declared here 5 |     return &local[0];   |            ^^^^^^^^^ returns reference to data owned by current function
```

**Fix:** Return by value, or take the data as a parameter with a lifetime.

### E0502: Lifetime Too Short[​](#e0502-lifetime-too-short "Direct link to E0502: Lifetime Too Short")

```
error[E0502]: lifetime 'a does not live long enough  --> src/example.ot:10:5   |   = help: The reference must be valid for 'b but it only lives for 'a
```

**Fix:** Ensure the borrowed data lives long enough, or restructure to avoid the borrow.

### E0505: Ambiguous Lifetime[​](#e0505-ambiguous-lifetime "Direct link to E0505: Ambiguous Lifetime")

```
error[E0505]: missing lifetime specifier  --> src/example.ot:2:40   | 2 | function pick(a: &T, b: &T): &T {   |                                 ^ expected named lifetime parameter   |help: consider introducing a named lifetime parameter: <'a>
```

**Fix:** Add explicit lifetime parameter to clarify which input the output borrows from.

## Interop with JavaScript/TypeScript[​](#interop-with-javascripttypescript "Direct link to Interop with JavaScript/TypeScript")

### .ot Files (Full Lifetime Support)[​](#ot-files-full-lifetime-support "Direct link to .ot Files (Full Lifetime Support)")

```
// Full lifetime tracking, zero-copy APIsexport function first<'a, T>(arr: &'a T[]): &'a T | null {    return arr.length > 0 ? &arr[0] : null;}
```

### .ts Files (Scope-Based Only)[​](#ts-files-scope-based-only "Direct link to .ts Files (Scope-Based Only)")

TypeScript files use scope-based borrow checking. References are valid within the function but cannot be returned:

```
// utils.ts - TypeScriptexport function process(arr: number[]): number {    return arr[0];  // Returns by value (copy)}
```

### .js Files (No Static Checking)[​](#js-files-no-static-checking "Direct link to .js Files (No Static Checking)")

JavaScript files run with ownership semantics but without compile-time checking:

```
// utils.js - dynamic modeexport function process(data) {    return data[0];  // No static checking, runtime ownership}
```

### npm Packages (.nroll)[​](#npm-packages-nroll "Direct link to npm Packages (.nroll)")

npm packages use copy-at-boundary semantics for safety:

```
import _ from "lodash";let items = [1, 2, 3];let sorted = _.sortBy(items);  // items is COPIED to lodash// items still usable (wasn't moved)
```

## Summary[​](#summary "Direct link to Summary")

| Concept         | Syntax          | When to Use                                   |
| --------------- | --------------- | --------------------------------------------- |
| Lifetime param  | `<'a>`          | Function/struct returning borrowed data       |
| Immutable ref   | `&'a T`         | Read-only access with explicit lifetime       |
| Mutable ref     | `&'a mut T`     | Write access with explicit lifetime           |
| Static lifetime | `'static`       | Data that lives forever (literals, constants) |
| Elision         | (no annotation) | Single input or method receiver               |

**Remember:** If the compiler asks for a lifetime, it's because it can't figure out how long your reference should live. The lifetime annotation tells it which input the output is borrowing from.

[Edit this page](https://github.com/warpy-ai/script/tree/main/docs/docs/lifetimes.md)
