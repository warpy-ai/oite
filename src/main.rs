mod compiler;
mod vm;

use crate::compiler::Codegen;
use crate::compiler::borrow_ck::BorrowChecker;
use crate::vm::VM;
use swc_common::{FileName, SourceMap, sync::Lrc};
use swc_ecma_parser::{Parser, StringInput, Syntax, lexer::Lexer};

#[cfg(test)]
mod tests;

fn main() {
    let cm: Lrc<SourceMap> = Default::default();

    // TEST CASE: Using 'a' twice should fail the Borrow Checker
    let code = "console.log('First');

setTimeout(() => {
    console.log('Third (Async)');
}, 0);

console.log('Second');";

    let fm = cm.new_source_file(FileName::Custom("input.js".into()).into(), code);
    let lexer = Lexer::new(
        Syntax::Es(Default::default()),
        Default::default(),
        StringInput::from(&*fm),
        None,
    );

    let mut parser = Parser::new_from(lexer);
    let module = parser.parse_module().expect("Parse failed");

    // 1. RUN BORROW CHECKER
    let mut bc = BorrowChecker::new();
    for item in &module.body {
        if let Some(stmt) = item.as_stmt()
            && let Err(e) = bc.analyze_stmt(stmt)
        {
            eprintln!("BORROW CHECK ERROR: {}", e);
            return;
        }
    }

    // 2. Codegen (Generate Bytecode)
    let mut cg = Codegen::new();
    let bytecode = cg.generate(&module);

    println!("Generated Bytecode:");
    for (i, op) in bytecode.iter().enumerate() {
        println!("  {:04}: {:?}", i, op);
    }

    // 3. Execution (VM)
    let mut my_vm = VM::new();

    println!("\nStarting VM Execution:");
    my_vm.load_program(bytecode);
    my_vm.run_event_loop();
}
