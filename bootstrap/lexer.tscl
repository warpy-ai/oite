// ============================================================================
// Bootstrap Lexer for tscl
// Self-hosting lexer implementation
// Requires: std/prelude.tscl to be loaded first
// ============================================================================

// ============================================================================
// Lexer State
// ============================================================================

function createLexer(source) {
    return {
        source: source,
        pos: 0,
        line: 1,
        col: 1,
        tokens: []
    };
}

// ============================================================================
// Core Scanning Functions
// ============================================================================

function lexerPeek(lexer) {
    if (lexer.pos >= lexer.source.length) {
        return -1;
    }
    return lexer.source.charCodeAt(lexer.pos);
}

function lexerPeekNext(lexer) {
    if (lexer.pos + 1 >= lexer.source.length) {
        return -1;
    }
    return lexer.source.charCodeAt(lexer.pos + 1);
}

function lexerAdvance(lexer) {
    let code = lexerPeek(lexer);
    lexer.pos = lexer.pos + 1;
    if (code == 10) {
        lexer.line = lexer.line + 1;
        lexer.col = 1;
    } else {
        lexer.col = lexer.col + 1;
    }
    return code;
}

// ============================================================================
// Whitespace and Comments
// ============================================================================

function skipWhitespace(lexer) {
    while (lexer.pos < lexer.source.length) {
        let code = lexerPeek(lexer);

        if (isWhitespace(code)) {
            lexerAdvance(lexer);
            continue;
        }

        // Check for comment: // (47 is '/')
        if (code == 47) {
            let nextCode = lexerPeekNext(lexer);
            if (nextCode == 47) {
                // Single-line comment
                lexerAdvance(lexer);
                lexerAdvance(lexer);
                while (lexer.pos < lexer.source.length) {
                    if (lexerPeek(lexer) == 10) {
                        lexerAdvance(lexer);
                        break;
                    }
                    lexerAdvance(lexer);
                }
                continue;
            }
        }

        return;
    }
}

// ============================================================================
// Token Scanners
// ============================================================================

function scanIdentifier(lexer) {
    let startLine = lexer.line;
    let startCol = lexer.col;
    let start = lexer.pos;

    while (lexer.pos < lexer.source.length && isAlphaNumeric(lexerPeek(lexer))) {
        lexerAdvance(lexer);
    }

    let value = lexer.source.slice(start, lexer.pos);
    return makeToken(TOKEN.IDENTIFIER, value, startLine, startCol);
}

function scanNumber(lexer) {
    let startLine = lexer.line;
    let startCol = lexer.col;
    let start = lexer.pos;

    while (lexer.pos < lexer.source.length && isDigit(lexerPeek(lexer))) {
        lexerAdvance(lexer);
    }

    // Check for decimal point
    if (lexerPeek(lexer) == 46) { // '.'
        lexerAdvance(lexer);
        while (lexer.pos < lexer.source.length && isDigit(lexerPeek(lexer))) {
            lexerAdvance(lexer);
        }
    }

    let value = lexer.source.slice(start, lexer.pos);
    return makeToken(TOKEN.NUMBER, value, startLine, startCol);
}

function scanString(lexer) {
    let startLine = lexer.line;
    let startCol = lexer.col;
    let quote = lexerPeek(lexer);
    lexerAdvance(lexer); // Skip opening quote

    let value = "";
    while (lexer.pos < lexer.source.length) {
        let code = lexerPeek(lexer);
        if (code == quote) {
            lexerAdvance(lexer);
            break;
        }
        if (code == 92) { // Backslash escape
            lexerAdvance(lexer);
            let nextCode = lexerPeek(lexer);
            if (nextCode == 110) { // 'n'
                value = value + "\n";
            } else if (nextCode == 116) { // 't'
                value = value + "\t";
            } else if (nextCode == 114) { // 'r'
                value = value + "\r";
            } else if (nextCode == 92) { // Backslash
                value = value + "\\";
            } else if (nextCode == 39) { // Single quote
                value = value + "'";
            } else if (nextCode == 34) { // Double quote
                value = value + "\"";
            } else {
                value = value + String.fromCharCode(nextCode);
            }
            lexerAdvance(lexer);
        } else {
            value = value + String.fromCharCode(code);
            lexerAdvance(lexer);
        }
    }

    return makeToken(TOKEN.STRING, value, startLine, startCol);
}

function scanOperatorOrDelimiter(lexer) {
    let startLine = lexer.line;
    let startCol = lexer.col;
    let start = lexer.pos;
    let code = lexerAdvance(lexer);

    // Multi-character operators
    if (code == 61) { // '='
        if (lexerPeek(lexer) == 61) { // '='
            lexerAdvance(lexer);
            if (lexerPeek(lexer) == 61) { // '='
                lexerAdvance(lexer);
                return makeToken(TOKEN.OPERATOR, "===", startLine, startCol);
            }
            return makeToken(TOKEN.OPERATOR, "==", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "=", startLine, startCol);
    }

    if (code == 38) { // '&'
        if (lexerPeek(lexer) == 38) { // '&'
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "&&", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "&", startLine, startCol);
    }

    if (code == 124) { // '|'
        if (lexerPeek(lexer) == 124) { // '|'
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "||", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "|", startLine, startCol);
    }

    if (code == 33) { // '!'
        if (lexerPeek(lexer) == 61) { // '='
            lexerAdvance(lexer);
            if (lexerPeek(lexer) == 61) { // '='
                lexerAdvance(lexer);
                return makeToken(TOKEN.OPERATOR, "!==", startLine, startCol);
            }
            return makeToken(TOKEN.OPERATOR, "!=", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "!", startLine, startCol);
    }

    if (code == 60) { // '<'
        if (lexerPeek(lexer) == 61) { // '='
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "<=", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "<", startLine, startCol);
    }

    if (code == 62) { // '>'
        if (lexerPeek(lexer) == 61) { // '='
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, ">=", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, ">", startLine, startCol);
    }

    if (code == 43) { // '+'
        if (lexerPeek(lexer) == 43) { // '+'
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "++", startLine, startCol);
        }
        if (lexerPeek(lexer) == 61) { // '='
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "+=", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "+", startLine, startCol);
    }

    if (code == 45) { // '-'
        if (lexerPeek(lexer) == 45) { // '-'
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "--", startLine, startCol);
        }
        if (lexerPeek(lexer) == 61) { // '='
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "-=", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "-", startLine, startCol);
    }

    if (code == 42) { // '*'
        if (lexerPeek(lexer) == 42) { // '*'
            lexerAdvance(lexer);
            if (lexerPeek(lexer) == 61) { // '='
                lexerAdvance(lexer);
                return makeToken(TOKEN.OPERATOR, "**=", startLine, startCol);
            }
            return makeToken(TOKEN.OPERATOR, "**", startLine, startCol);
        }
        if (lexerPeek(lexer) == 61) { // '='
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "*=", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "*", startLine, startCol);
    }

    if (code == 47) { // '/'
        if (lexerPeek(lexer) == 61) { // '='
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, "/=", startLine, startCol);
        }
        return makeToken(TOKEN.OPERATOR, "/", startLine, startCol);
    }

    // Single character operators and delimiters
    if (code == 37) { return makeToken(TOKEN.OPERATOR, "%", startLine, startCol); } // %
    if (code == 94) { return makeToken(TOKEN.OPERATOR, "^", startLine, startCol); } // ^

    if (code == 123) { return makeToken(TOKEN.DELIMITER, "{", startLine, startCol); } // {
    if (code == 125) { return makeToken(TOKEN.DELIMITER, "}", startLine, startCol); } // }
    if (code == 40) { return makeToken(TOKEN.DELIMITER, "(", startLine, startCol); } // (
    if (code == 41) { return makeToken(TOKEN.DELIMITER, ")", startLine, startCol); } // )
    if (code == 91) { return makeToken(TOKEN.DELIMITER, "[", startLine, startCol); } // [
    if (code == 93) { return makeToken(TOKEN.DELIMITER, "]", startLine, startCol); } // ]
    if (code == 46) { return makeToken(TOKEN.DELIMITER, ".", startLine, startCol); } // .
    if (code == 59) { return makeToken(TOKEN.DELIMITER, ";", startLine, startCol); } // ;
    if (code == 58) { return makeToken(TOKEN.DELIMITER, ":", startLine, startCol); } // :
    if (code == 44) { return makeToken(TOKEN.DELIMITER, ",", startLine, startCol); } // ,

    // Unknown character
    return makeToken(TOKEN.OPERATOR, String.fromCharCode(code), startLine, startCol);
}

// ============================================================================
// Token Factory
// ============================================================================

function makeToken(type, value, line, col) {
    return {
        type: type,
        value: value,
        line: line,
        col: col
    };
}

// ============================================================================
// Main Tokenization Function
// ============================================================================

function tokenize(source) {
    let lexer = createLexer(source);

    while (lexer.pos < lexer.source.length) {
        skipWhitespace(lexer);

        if (lexer.pos >= lexer.source.length) {
            break;
        }

        let code = lexerPeek(lexer);
        if (code == -1) {
            break;
        }

        let token;

        if (isAlpha(code)) {
            token = scanIdentifier(lexer);
        } else if (isDigit(code)) {
            token = scanNumber(lexer);
        } else if (code == 34 || code == 39) {
            token = scanString(lexer);
        } else {
            token = scanOperatorOrDelimiter(lexer);
        }

        lexer.tokens.push(token);
    }

    // Add EOF token
    lexer.tokens.push(makeToken(TOKEN.EOF, "", lexer.line, lexer.col));

    return lexer.tokens;
}
