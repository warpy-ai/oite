// ============================================================================
// Bootstrap Parser for tscl
// Recursive descent parser - consumes tokens, produces AST
// Requires: std/prelude.tscl, bootstrap/types.tscl, and bootstrap/lexer.tscl
// ============================================================================

// ============================================================================
// Parser State
// ============================================================================

function createParser(tokens) {
    return {
        tokens: tokens,
        pos: 0
    };
}

// ============================================================================
// Utility Functions
// ============================================================================

function parserPeek(parser) {
    if (parser.pos >= parser.tokens.length) {
        return null;
    }
    return parser.tokens[parser.pos];
}

function peekType(parser) {
    let tok =  parserPeek(parser);
    if (tok == null) {
        return TOKEN.EOF;
    }
    return tok.type;
}

function peekValue(parser) {
    let tok =  parserPeek(parser);
    if (tok == null) {
        return "";
    }
    return tok.value;
}

function parserAdvance(parser) {
    let tok =  parserPeek(parser);
    parser.pos = parser.pos + 1;
    return tok;
}

function check(parser, type, value) {
    let tok =  parserPeek(parser);
    if (tok == null) {
        return false;
    }
    if (tok.type != type) {
        return false;
    }
    if (value != null && tok.value != value) {
        return false;
    }
    return true;
}

function match(parser, type, value) {
    if (check(parser, type, value)) {
        parserAdvance(parser);
        return true;
    }
    return false;
}

function expect(parser, type, value) {
    if (check(parser, type, value)) {
        return parserAdvance(parser);
    }
    let tok =  parserPeek(parser);
    let tokVal =  "";
    let tokType =  TOKEN.EOF;
    if (tok != null) {
        tokVal = tok.value;
        tokType = tok.type;
    }
    console.log("Parse error: expected", type, value, "but got", tokType, tokVal);
    return null;
}

function isAtEnd(parser) {
    return peekType(parser) == TOKEN.EOF;
}

// ============================================================================
// Type Annotation Parsers
// ============================================================================

// Parse a type annotation after ':'
// Examples: number, string, boolean, any, void, Array<T>, T[], Promise<T>, A | B
function parseTypeAnnotation(parser) {
    let baseType = parseBaseType(parser);
    if (baseType == null) {
        return null;
    }

    // Check for union type: A | B
    if (check(parser, TOKEN.OPERATOR, "|")) {
        let unionTypes = [baseType];
        while (match(parser, TOKEN.OPERATOR, "|")) {
            let nextType = parseBaseType(parser);
            if (nextType != null) {
                unionTypes.push(nextType);
            }
        }
        return {
            type: "TypeAnnotation",
            typeKind: "union",
            isArray: false,
            elementType: null,
            unionTypes: unionTypes,
            genericParams: null
        };
    }

    return baseType;
}

// Parse base type: number, string, Array<T>, T[], etc.
function parseBaseType(parser) {
    let typeKind = "";

    // Check for identifier (type name)
    if (peekType(parser) == TOKEN.IDENTIFIER || peekType(parser) == TOKEN.KEYWORD) {
        let tok = parserAdvance(parser);
        typeKind = tok.value;
    } else {
        return null;
    }

    // Check for generic parameters: Type<T, U>
    let genericParams = null;
    if (check(parser, TOKEN.OPERATOR, "<")) {
        parserAdvance(parser);
        genericParams = [];
        while (!check(parser, TOKEN.OPERATOR, ">")) {
            if (genericParams.length > 0) {
                expect(parser, TOKEN.DELIMITER, ",");
            }
            let paramType = parseTypeAnnotation(parser);
            if (paramType != null) {
                genericParams.push(paramType);
            }
        }
        expect(parser, TOKEN.OPERATOR, ">");
    }

    // Check for array notation: type[]
    let isArray = false;
    let elementType = null;
    if (check(parser, TOKEN.DELIMITER, "[")) {
        parserAdvance(parser);
        expect(parser, TOKEN.DELIMITER, "]");
        isArray = true;
        elementType = {
            type: "TypeAnnotation",
            typeKind: typeKind,
            isArray: false,
            elementType: null,
            unionTypes: null,
            genericParams: genericParams
        };
        typeKind = "array";
        genericParams = null;
    }

    return {
        type: "TypeAnnotation",
        typeKind: typeKind,
        isArray: isArray,
        elementType: elementType,
        unionTypes: null,
        genericParams: genericParams
    };
}

// Try to parse optional type annotation (: type)
function tryParseTypeAnnotation(parser) {
    if (check(parser, TOKEN.DELIMITER, ":")) {
        parserAdvance(parser);
        return parseTypeAnnotation(parser);
    }
    return null;
}

// ============================================================================
// Statement Parsers
// ============================================================================

function parseProgram(parser) {
    let programBody =  [];

    while (!isAtEnd(parser)) {
        let stmt =  parseStatement(parser);
        if (stmt != null) {
            programBody.push(stmt);
        } else {
            parserAdvance(parser);
        }
    }

    return {
        type: "Program",
        body: programBody
    };
}

function parseStatement(parser) {
    let type =  peekType(parser);

    if (type == TOKEN.KEYWORD) {
        let value =  peekValue(parser);
        if (value == "let" || value == "const" || value == "var") {
            return parseVariableDeclaration(parser);
        }
        if (value == "function") {
            return parseFunctionDeclaration(parser);
        }
        if (value == "async") {
            // async function declaration
            return parseFunctionDeclaration(parser);
        }
        if (value == "import") {
            return parseImportDeclaration(parser);
        }
        if (value == "export") {
            return parseExportDeclaration(parser);
        }
        if (value == "return") {
            return parseReturnStatement(parser);
        }
        if (value == "if") {
            return parseIfStatement(parser);
        }
        if (value == "while") {
            return parseWhileStatement(parser);
        }
        if (value == "for") {
            return parseForStatement(parser);
        }
        if (value == "break") {
            return parseBreakStatement(parser);
        }
        if (value == "continue") {
            return parseContinueStatement(parser);
        }
    }

    if (type == TOKEN.DELIMITER) {
        let value =  peekValue(parser);
        if (value == "{") {
            return parseBlockStatement(parser);
        }
    }

    // Try to parse as expression statement
    let expr =  parseExpression(parser, 0);
    if (expr != null) {
        // Check for semicolon
        match(parser, TOKEN.DELIMITER, ";");
        return {
            type: "ExpressionStatement",
            expression: expr
        };
    }

    return null;
}

function parseBlockStatement(parser) {
    expect(parser, TOKEN.DELIMITER, "{");

    let body =  [];

    while (!check(parser, TOKEN.DELIMITER, "}")) {
        if (isAtEnd(parser)) {
            console.log("Parse error: unclosed block");
            break;
        }
        let stmt =  parseStatement(parser);
        if (stmt != null) {
            body.push(stmt);
        } else {
            parserAdvance(parser);
        }
    }

    expect(parser, TOKEN.DELIMITER, "}");

    return {
        type: "BlockStatement",
        body: body
    };
}

function parseVariableDeclaration(parser) {
    let kind =  peekValue(parser);
    parserAdvance(parser);

    let name =  "";
    let nameTok =  expect(parser, TOKEN.IDENTIFIER, null);
    if (nameTok != null) {
        name = nameTok.value;
    }

    // Parse optional type annotation: let x: number
    let typeAnnotation = tryParseTypeAnnotation(parser);

    let init =  null;
    if (match(parser, TOKEN.OPERATOR, "=")) {
        init = parseExpression(parser, 0);
    }

    match(parser, TOKEN.DELIMITER, ";");

    return {
        type: "VariableDeclaration",
        name: name,
        typeAnnotation: typeAnnotation,
        init: init,
        kind: kind
    };
}

function parseFunctionDeclaration(parser) {
    // Check for async keyword
    let isAsync = false;
    if (check(parser, TOKEN.KEYWORD, "async")) {
        parserAdvance(parser);
        isAsync = true;
    }

    expect(parser, TOKEN.KEYWORD, "function");

    let name =  "";
    let nameTok =  expect(parser, TOKEN.IDENTIFIER, null);
    if (nameTok != null) {
        name = nameTok.value;
    }

    expect(parser, TOKEN.DELIMITER, "(");

    let params =  [];
    while (!check(parser, TOKEN.DELIMITER, ")")) {
        if (params.length > 0) {
            expect(parser, TOKEN.DELIMITER, ",");
        }
        let paramTok =  expect(parser, TOKEN.IDENTIFIER, null);
        if (paramTok != null) {
            // Check for parameter type annotation: param: type
            let paramType = tryParseTypeAnnotation(parser);
            if (paramType != null) {
                params.push({
                    name: paramTok.value,
                    typeAnnotation: paramType
                });
            } else {
                params.push(paramTok.value);
            }
        }
    }

    expect(parser, TOKEN.DELIMITER, ")");

    // Parse optional return type annotation: ): type
    let returnType = tryParseTypeAnnotation(parser);

    let body =  parseBlockStatement(parser);

    return {
        type: "FunctionDeclaration",
        name: name,
        params: params,
        returnType: returnType,
        body: body,
        isAsync: isAsync
    };
}

function parseReturnStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "return");

    let argument =  null;
    if (!check(parser, TOKEN.DELIMITER, ";") && !isAtEnd(parser)) {
        argument = parseExpression(parser, 0);
    }

    match(parser, TOKEN.DELIMITER, ";");

    return {
        type: "ReturnStatement",
        argument: argument
    };
}

function parseIfStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "if");
    expect(parser, TOKEN.DELIMITER, "(");

    let test =  parseExpression(parser, 0);

    expect(parser, TOKEN.DELIMITER, ")");

    let consequent: Statement;
    if (check(parser, TOKEN.DELIMITER, "{")) {
        consequent = parseBlockStatement(parser);
    } else {
        let stmt =  parseStatement(parser);
        if (stmt == null) {
            consequent = { type: "EmptyStatement" };
        } else {
            consequent = stmt;
        }
    }

    let alternate =  null;
    if (match(parser, TOKEN.KEYWORD, "else")) {
        if (check(parser, TOKEN.KEYWORD, "if")) {
            alternate = parseIfStatement(parser);
        } else if (check(parser, TOKEN.DELIMITER, "{")) {
            alternate = parseBlockStatement(parser);
        } else {
            let stmt =  parseStatement(parser);
            alternate = stmt;
        }
    }

    return {
        type: "IfStatement",
        test: test,
        consequent: consequent,
        alternate: alternate
    };
}

function parseWhileStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "while");
    expect(parser, TOKEN.DELIMITER, "(");

    let test =  parseExpression(parser, 0);

    expect(parser, TOKEN.DELIMITER, ")");

    let body: Statement;
    if (check(parser, TOKEN.DELIMITER, "{")) {
        body = parseBlockStatement(parser);
    } else {
        let stmt =  parseStatement(parser);
        if (stmt == null) {
            body = { type: "EmptyStatement" };
        } else {
            body = stmt;
        }
    }

    return {
        type: "WhileStatement",
        test: test,
        body: body
    };
}

function parseForStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "for");
    expect(parser, TOKEN.DELIMITER, "(");

    let init =  null;
    if (!check(parser, TOKEN.DELIMITER, ";")) {
        if (peekType(parser) == TOKEN.KEYWORD) {
            let value =  peekValue(parser);
            if (value == "let" || value == "const" || value == "var") {
                init = parseVariableDeclaration(parser);
            }
        } else {
            init = {
                type: "ExpressionStatement",
                expression: parseExpression(parser, 0)
            };
        }
    }

    let test =  null;
    if (!check(parser, TOKEN.DELIMITER, ";")) {
        test = parseExpression(parser, 0);
    }

    expect(parser, TOKEN.DELIMITER, ";");

    let update =  null;
    if (!check(parser, TOKEN.DELIMITER, ")")) {
        update = parseExpression(parser, 0);
    }

    expect(parser, TOKEN.DELIMITER, ")");

    let body: Statement;
    if (check(parser, TOKEN.DELIMITER, "{")) {
        body = parseBlockStatement(parser);
    } else {
        let stmt =  parseStatement(parser);
        body = stmt;
    }

    return {
        type: "ForStatement",
        init: init,
        test: test,
        update: update,
        body: body
    };
}

function parseBreakStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "break");
    match(parser, TOKEN.DELIMITER, ";");
    return { type: "BreakStatement" };
}

function parseContinueStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "continue");
    match(parser, TOKEN.DELIMITER, ";");
    return { type: "ContinueStatement" };
}

// ============================================================================
// Module Declaration Parsers (import/export)
// ============================================================================

// Parse: import { a, b } from './module';
// Parse: import defaultExport from './module';
// Parse: import * as ns from './module';
// Parse: import './module';
function parseImportDeclaration(parser) {
    expect(parser, TOKEN.KEYWORD, "import");

    let specifiers = [];
    let source = "";

    // Check for side-effect only import: import './module';
    if (peekType(parser) == TOKEN.STRING) {
        let sourceTok = parserAdvance(parser);
        source = sourceTok.value;
        match(parser, TOKEN.DELIMITER, ";");
        return {
            type: "ImportDeclaration",
            specifiers: [],
            source: source
        };
    }

    // Check for namespace import: import * as ns from './module';
    if (check(parser, TOKEN.OPERATOR, "*")) {
        parserAdvance(parser);
        expect(parser, TOKEN.KEYWORD, "as");
        let localTok = expect(parser, TOKEN.IDENTIFIER, null);
        if (localTok != null) {
            specifiers.push({
                type: "ImportNamespaceSpecifier",
                local: localTok.value
            });
        }
    }
    // Check for default import: import defaultExport from './module';
    else if (peekType(parser) == TOKEN.IDENTIFIER && !check(parser, TOKEN.DELIMITER, "{")) {
        let localTok = parserAdvance(parser);
        specifiers.push({
            type: "ImportDefaultSpecifier",
            local: localTok.value
        });

        // Check for comma followed by named imports: import default, { a, b } from './module';
        if (match(parser, TOKEN.DELIMITER, ",")) {
            if (check(parser, TOKEN.DELIMITER, "{")) {
                let namedSpecifiers = parseNamedImports(parser);
                for (let i = 0; i < namedSpecifiers.length; i = i + 1) {
                    specifiers.push(namedSpecifiers[i]);
                }
            }
        }
    }
    // Named imports: import { a, b } from './module';
    else if (check(parser, TOKEN.DELIMITER, "{")) {
        specifiers = parseNamedImports(parser);
    }

    expect(parser, TOKEN.KEYWORD, "from");

    let sourceTok = expect(parser, TOKEN.STRING, null);
    if (sourceTok != null) {
        source = sourceTok.value;
    }

    match(parser, TOKEN.DELIMITER, ";");

    return {
        type: "ImportDeclaration",
        specifiers: specifiers,
        source: source
    };
}

// Parse named imports: { a, b as c, d }
function parseNamedImports(parser) {
    let specifiers = [];
    expect(parser, TOKEN.DELIMITER, "{");

    while (!check(parser, TOKEN.DELIMITER, "}")) {
        if (specifiers.length > 0) {
            expect(parser, TOKEN.DELIMITER, ",");
        }

        if (check(parser, TOKEN.DELIMITER, "}")) {
            break;
        }

        let importedTok = expect(parser, TOKEN.IDENTIFIER, null);
        if (importedTok == null) {
            break;
        }

        let imported = importedTok.value;
        let local = imported;

        // Check for alias: a as b
        if (match(parser, TOKEN.KEYWORD, "as")) {
            let localTok = expect(parser, TOKEN.IDENTIFIER, null);
            if (localTok != null) {
                local = localTok.value;
            }
        }

        specifiers.push({
            type: "ImportSpecifier",
            imported: imported,
            local: local
        });
    }

    expect(parser, TOKEN.DELIMITER, "}");
    return specifiers;
}

// Parse: export { a, b };
// Parse: export { a } from './module';
// Parse: export * from './module';
// Parse: export default expr;
// Parse: export const x = 1;
// Parse: export function foo() {}
function parseExportDeclaration(parser) {
    expect(parser, TOKEN.KEYWORD, "export");

    // export default expr;
    if (match(parser, TOKEN.KEYWORD, "default")) {
        let declaration = null;

        // export default function foo() {}
        if (check(parser, TOKEN.KEYWORD, "function") || check(parser, TOKEN.KEYWORD, "async")) {
            declaration = parseFunctionDeclaration(parser);
        } else {
            // export default expression;
            declaration = parseExpression(parser, 0);
            match(parser, TOKEN.DELIMITER, ";");
        }

        return {
            type: "ExportDefaultDeclaration",
            declaration: declaration
        };
    }

    // export * from './module';
    if (check(parser, TOKEN.OPERATOR, "*")) {
        parserAdvance(parser);
        expect(parser, TOKEN.KEYWORD, "from");
        let sourceTok = expect(parser, TOKEN.STRING, null);
        let source = "";
        if (sourceTok != null) {
            source = sourceTok.value;
        }
        match(parser, TOKEN.DELIMITER, ";");

        return {
            type: "ExportAllDeclaration",
            source: source
        };
    }

    // export { a, b } or export { a } from './module';
    if (check(parser, TOKEN.DELIMITER, "{")) {
        let specifiers = parseNamedExports(parser);
        let source = null;

        // Check for re-export: export { a } from './module';
        if (match(parser, TOKEN.KEYWORD, "from")) {
            let sourceTok = expect(parser, TOKEN.STRING, null);
            if (sourceTok != null) {
                source = sourceTok.value;
            }
        }

        match(parser, TOKEN.DELIMITER, ";");

        return {
            type: "ExportNamedDeclaration",
            specifiers: specifiers,
            source: source,
            declaration: null
        };
    }

    // export const/let/var x = 1;
    if (check(parser, TOKEN.KEYWORD, "let") || check(parser, TOKEN.KEYWORD, "const") || check(parser, TOKEN.KEYWORD, "var")) {
        let declaration = parseVariableDeclaration(parser);
        return {
            type: "ExportNamedDeclaration",
            specifiers: [],
            source: null,
            declaration: declaration
        };
    }

    // export function foo() {} or export async function foo() {}
    if (check(parser, TOKEN.KEYWORD, "function") || check(parser, TOKEN.KEYWORD, "async")) {
        let declaration = parseFunctionDeclaration(parser);
        return {
            type: "ExportNamedDeclaration",
            specifiers: [],
            source: null,
            declaration: declaration
        };
    }

    console.log("Parse error: unexpected export syntax");
    return null;
}

// Parse named exports: { a, b as c }
function parseNamedExports(parser) {
    let specifiers = [];
    expect(parser, TOKEN.DELIMITER, "{");

    while (!check(parser, TOKEN.DELIMITER, "}")) {
        if (specifiers.length > 0) {
            expect(parser, TOKEN.DELIMITER, ",");
        }

        if (check(parser, TOKEN.DELIMITER, "}")) {
            break;
        }

        let localTok = expect(parser, TOKEN.IDENTIFIER, null);
        if (localTok == null) {
            break;
        }

        let local = localTok.value;
        let exported = local;

        // Check for alias: a as b
        if (match(parser, TOKEN.KEYWORD, "as")) {
            let exportedTok = expect(parser, TOKEN.IDENTIFIER, null);
            if (exportedTok != null) {
                exported = exportedTok.value;
            }
        }

        specifiers.push({
            type: "ExportSpecifier",
            local: local,
            exported: exported
        });
    }

    expect(parser, TOKEN.DELIMITER, "}");
    return specifiers;
}

// ============================================================================
// Expression Parsers (Pratt Parser)
// ============================================================================

const PRECEDENCE =  {
    "=": 1,
    "||": 2,
    "&&": 3,
    "|": 4,
    "^": 5,
    "&": 6,
    "==": 7, "!=": 7, "===": 7, "!==": 7,
    "<": 8, "<=": 8, ">": 8, ">=": 8,
    "<<": 9, ">>": 9, ">>>": 9,
    "+": 10, "-": 10,
    "*": 11, "/": 11, "%": 11, "**": 12,
    ".": 14,
    "[": 14,
    "(": 15
};

function parseExpression(parser, minPrec) {
    let tok =  parserPeek(parser);
    if (tok == null) {
        return null;
    }

    let left: Expression | null;

    // Prefix operators
    if (tok.type == TOKEN.OPERATOR) {
        let op =  tok.value;
        if (op == "!" || op == "-" || op == "+" || op == "~" || op == "typeof" || op == "void" || op == "delete") {
            parserAdvance(parser);
            let argument =  parseExpression(parser, 13);
            if (argument == null) {
                return null;
            }
            left = {
                type: "UnaryExpression",
                operator: op,
                argument: argument
            };
        } else {
            return null;
        }
    } else if (tok.type == TOKEN.NUMBER) {
        parserAdvance(parser);
        let numVal = parseFloat(tok.value);
        let lit = {
            type: "Literal",
            literalType: "number",
            value: numVal
        };
        left = lit;
    } else if (tok.type == TOKEN.STRING) {
    } else if (tok.type == TOKEN.STRING) {
        parserAdvance(parser);
        left = {
            type: "Literal",
            literalType: "string",
            value: tok.value
        };
    } else if (tok.type == TOKEN.KEYWORD && tok.value == "null") {
        parserAdvance(parser);
        left = {
            type: "Literal",
            literalType: "null",
            value: null
        };
    } else if (tok.type == TOKEN.KEYWORD && (tok.value == "true" || tok.value == "false")) {
        parserAdvance(parser);
        left = {
            type: "Literal",
            literalType: "boolean",
            value: tok.value == "true"
        };
    } else if (tok.type == TOKEN.IDENTIFIER) {
        parserAdvance(parser);
        left = {
            type: "Identifier",
            name: tok.value
        };
    } else if (tok.type == TOKEN.KEYWORD && tok.value == "this") {
        parserAdvance(parser);
        left = { type: "ThisExpression" };
    } else if (match(parser, TOKEN.DELIMITER, "(")) {
        // Parenthesized expression or arrow function
        if (peekType(parser) == TOKEN.IDENTIFIER) {
            // Check for arrow function
            let nextToken =  parser.tokens[parser.pos + 1];
            if (nextToken != null && nextToken.value == "=>") {
                // Arrow function: (param) => body
                let params =  [];
                params.push(tok.value);

                parserAdvance(parser); // Consume identifier
                parserAdvance(parser); // Consume "=>"

                let body: BlockStatement | Expression;
                if (check(parser, TOKEN.DELIMITER, "{")) {
                    body = parseBlockStatement(parser);
                } else {
                    let expr =  parseExpression(parser, 0);
                    if (expr == null) {
                        body = { type: "BlockStatement", body: [] };
                    } else {
                        body = expr;
                    }
                }

                left = {
                    type: "ArrowFunctionExpression",
                    params: params,
                    body: body
                };
            } else {
                // Parenthesized expression
                let expr =  parseExpression(parser, 0);
                expect(parser, TOKEN.DELIMITER, ")");
                left = expr;
            }
        } else {
            let expr =  parseExpression(parser, 0);
            expect(parser, TOKEN.DELIMITER, ")");
            left = expr;
        }
    } else if (match(parser, TOKEN.DELIMITER, "{")) {
        // Object literal
        let properties =  [];

        while (!check(parser, TOKEN.DELIMITER, "}")) {
            if (properties.length > 0) {
                expect(parser, TOKEN.DELIMITER, ",");
            }

            let keyTok =  expect(parser, TOKEN.IDENTIFIER, null);
            if (keyTok == null) {
                break;
            }

            let key: Identifier | Literal = {
                type: "Identifier",
                name: keyTok.value
            };

            expect(parser, TOKEN.DELIMITER, ":");

            let value =  parseExpression(parser, 0);

            properties.push({
                key: key,
                value: value,
                kind: "init"
            });
        }

        expect(parser, TOKEN.DELIMITER, "}");

        left = {
            type: "ObjectExpression",
            properties: properties
        };
    } else if (match(parser, TOKEN.DELIMITER, "[")) {
        // Array literal
        let elements: Array<Expression | null> = [];

        while (!check(parser, TOKEN.DELIMITER, "]")) {
            if (elements.length > 0) {
                expect(parser, TOKEN.DELIMITER, ",");
            }

            if (check(parser, TOKEN.DELIMITER, "]")) {
                break;
            }

            let element =  parseExpression(parser, 0);
            elements.push(element);
        }

        expect(parser, TOKEN.DELIMITER, "]");

        left = {
            type: "ArrayExpression",
            elements: elements
        };
    } else {
        return null;
    }

    // Parse postfix operators and binary operators
    while (true) {
        let nextPrec =  0;
        let op =  "";

        if (match(parser, TOKEN.DELIMITER, "(")) {
            // Function call
            let callee =  left;

            let arguments =  [];
            while (!check(parser, TOKEN.DELIMITER, ")")) {
                if (arguments.length > 0) {
                    expect(parser, TOKEN.DELIMITER, ",");
                }

                let arg =  parseExpression(parser, 0);
                if (arg != null) {
                    arguments.push(arg);
                }
            }

            expect(parser, TOKEN.DELIMITER, ")");

            left = {
                type: "CallExpression",
                callee: callee,
                arguments: arguments
            };
        } else if (match(parser, TOKEN.DELIMITER, ".")) {
            // Property access
            let propertyTok =  expect(parser, TOKEN.IDENTIFIER, null);
            if (propertyTok == null) {
                break;
            }

            left = {
                type: "MemberExpression",
                object: left,
                property: {
                    type: "Identifier",
                    name: propertyTok.value
                },
                computed: false
            };
        } else if (match(parser, TOKEN.DELIMITER, "[")) {
            // Computed property access
            let property =  parseExpression(parser, 0);
            expect(parser, TOKEN.DELIMITER, "]");

            left = {
                type: "MemberExpression",
                object: left,
                property: property,
                computed: true
            };
        } else if (peekType(parser) == TOKEN.OPERATOR) {
            let opTok =  parserPeek(parser);
            op = opTok.value;

            if (op == "=>") {
                // Arrow function
                parserAdvance(parser);

                let params =  [];
                if (left.type == "Identifier") {
                    params.push(left.name);
                } else if (left.type == "CallExpression") {
                    console.log("ERROR: Function call not allowed before arrow");
                    break;
                }

                let body: BlockStatement | Expression;
                if (check(parser, TOKEN.DELIMITER, "{")) {
                    body = parseBlockStatement(parser);
                } else {
                    let expr =  parseExpression(parser, 0);
                    if (expr == null) {
                        body = { type: "BlockStatement", body: [] };
                    } else {
                        body = expr;
                    }
                }

                left = {
                    type: "ArrowFunctionExpression",
                    params: params,
                    body: body
                };
            } else if (PRECEDENCE[op] != null) {
                nextPrec = PRECEDENCE[op];

                if (nextPrec <= minPrec) {
                    break;
                }

                parserAdvance(parser);

                let right =  parseExpression(parser, nextPrec);

                if (right == null) {
                    break;
                }

                if (op == "=") {
                    // Assignment
                    if (left.type == "Identifier" || left.type == "MemberExpression") {
                        left = {
                            type: "AssignmentExpression",
                            operator: op,
                            left: left,
                            right: right
                        };
                    } else {
                        console.log("ERROR: Invalid assignment target");
                    }
                } else {
                    // Binary operation
                    left = {
                        type: "BinaryExpression",
                        operator: op,
                        left: left,
                        right: right
                    };
                }
            } else {
                break;
            }
        } else {
            break;
        }
    }

    return left;
}

// ============================================================================
// Source Code Entry Point
// ============================================================================

function parseSource(source) {
    let tokens =  tokenize(source);
    let parser =  createParser(tokens);
    return parseProgram(parser);
}
